package cartridge

import (
	"os"
	"strings"
	"time"

	"github.com/gofiber/fiber/v2"
	"github.com/gofiber/fiber/v2/middleware/cors"
	"github.com/gofiber/fiber/v2/middleware/csrf"
	"github.com/gofiber/fiber/v2/middleware/helmet"
	"github.com/gofiber/fiber/v2/middleware/limiter"
	"github.com/gofiber/fiber/v2/middleware/logger"
	"github.com/gofiber/fiber/v2/middleware/recover"
	"github.com/gofiber/fiber/v2/middleware/requestid"
)

// RequestID generates a unique request ID for tracing
func RequestID() fiber.Handler {
	return requestid.New()
}

// RecoveryConfig holds recovery middleware configuration
type RecoveryConfig struct {
	EnableStackTrace bool
	SkipHealthChecks bool
}

// Recovery provides panic recovery with stack traces
func Recovery(config RecoveryConfig) fiber.Handler {
	return recover.New(recover.Config{
		EnableStackTrace: config.EnableStackTrace,
		Next: func(c *fiber.Ctx) bool {
			// Skip recovery for health checks if configured
			return config.SkipHealthChecks && c.Path() == "/health"
		},
	})
}

// LoggerConfig holds logging middleware configuration
type LoggerConfig struct {
	Format           string
	SkipHealthChecks bool
	SkipStaticAssets bool
	SkipPaths        []string
}

// LoggerMiddleware provides HTTP request/response logging
func LoggerMiddleware(config LoggerConfig) fiber.Handler {
	return logger.New(logger.Config{
		Format: config.Format,
		Output: os.Stdout,
		Next: func(c *fiber.Ctx) bool {
			path := c.Path()

			// Skip health checks if configured
			if config.SkipHealthChecks && path == "/health" {
				return true
			}

			// Skip static assets if configured
			if config.SkipStaticAssets && (strings.HasPrefix(path, "/static/") || strings.HasPrefix(path, "/assets/")) {
				return true
			}

			// Skip custom paths
			for _, skipPath := range config.SkipPaths {
				if strings.HasPrefix(path, skipPath) {
					return true
				}
			}

			return false
		},
	})
}

// HelmetConfig holds security headers configuration
type HelmetConfig struct {
	ReferrerPolicy string
}

// Helmet provides security headers based on configuration
func Helmet(config HelmetConfig) fiber.Handler {
	return helmet.New(helmet.Config{
		ReferrerPolicy: config.ReferrerPolicy,
	})
}

// MethodOverride supports _method form field for PUT/DELETE via POST
func MethodOverride() fiber.Handler {
	return func(c *fiber.Ctx) error {
		// Check for _method in forms
		if method := c.FormValue("_method"); method != "" {
			c.Method(strings.ToUpper(method))
		}
		return c.Next()
	}
}

// CSRFConfig holds CSRF protection configuration
type CSRFConfig struct {
	ExcludedPaths  []string
	CookieName     string
	CookieSameSite string
	CookieSecure   bool
	Expiration     time.Duration
	ContextKey     string
	KeyLookup      string
}

// DefaultCSRFConfig returns default CSRF configuration
func DefaultCSRFConfig() CSRFConfig {
	return CSRFConfig{
		ExcludedPaths:  []string{"/api/", "/static/"},
		CookieName:     "_csrf_token",
		CookieSameSite: "Lax",
		CookieSecure:   false, // Will be set based on environment
		Expiration:     2 * time.Hour,
		ContextKey:     "csrf",
		KeyLookup:      "header:X-CSRF-Token",
	}
}

// CSRF provides simplified CSRF protection
func CSRF(logger Logger, config CSRFConfig) fiber.Handler {
	// Ensure config has proper defaults if KeyLookup is empty
	if config.KeyLookup == "" {
		config = DefaultCSRFConfig()
	}

	logger.Info("About to create fiber CSRF config", "keyLookup", config.KeyLookup, "cookieName", config.CookieName)
	csrfConfig := csrf.Config{
		KeyLookup:      config.KeyLookup,
		CookieName:     config.CookieName,
		CookieSameSite: config.CookieSameSite,
		CookieSecure:   config.CookieSecure,
		Expiration:     config.Expiration,
		ContextKey:     config.ContextKey,
		Next: func(c *fiber.Ctx) bool {
			return IsExcludedPath(c.Path(), config.ExcludedPaths)
		},
	}

	return csrf.New(csrfConfig)
}

// CSRFTokenInjector injects CSRF token into request context after CSRF middleware runs
func CSRFTokenInjector(config CSRFConfig) fiber.Handler {
	return func(c *fiber.Ctx) error {
		// Skip injection for excluded paths
		if IsExcludedPath(c.Path(), config.ExcludedPaths) {
			return c.Next()
		}

		// Get the CSRF token generated by the CSRF middleware and inject it into locals
		// This makes it available for controllers to access
		if token := c.Get("X-CSRF-Token"); token != "" {
			c.Locals(config.ContextKey, token)
		}

		return c.Next()
	}
}

// RateLimiterConfig holds rate limiting configuration
type RateLimiterConfig struct {
	Max      int
	Duration time.Duration
}

// DefaultRateLimiterConfig returns default rate limiting configuration
func DefaultRateLimiterConfig() RateLimiterConfig {
	return RateLimiterConfig{
		Max:      50,
		Duration: 1 * time.Second,
	}
}

// RateLimiter provides IP-based rate limiting
func RateLimiter(config RateLimiterConfig) fiber.Handler {
	return limiter.New(limiter.Config{
		Max:        config.Max,
		Expiration: config.Duration,
	})
}

// CORSConfig holds CORS configuration
type CORSConfig struct {
	AllowOrigins     []string
	AllowMethods     []string
	AllowHeaders     []string
	AllowCredentials bool
	MaxAge           int
}

// DefaultCORSConfig returns default CORS configuration
func DefaultCORSConfig() CORSConfig {
	return CORSConfig{
		AllowOrigins:     []string{"*"},
		AllowMethods:     []string{"GET", "POST", "PUT", "DELETE", "OPTIONS"},
		AllowHeaders:     []string{"Accept", "Authorization", "Content-Type", "X-CSRF-Token"},
		AllowCredentials: false,
		MaxAge:           0,
	}
}

// ProductionCORSConfig returns CORS configuration suitable for production
func ProductionCORSConfig(allowedOrigins []string) CORSConfig {
	if len(allowedOrigins) == 0 {
		allowedOrigins = []string{"https://localhost:3000"} // Default safe origin
	}

	return CORSConfig{
		AllowOrigins:     allowedOrigins,
		AllowMethods:     []string{"GET", "POST", "PUT", "DELETE", "OPTIONS"},
		AllowHeaders:     []string{"Accept", "Authorization", "Content-Type", "X-CSRF-Token"},
		AllowCredentials: true,
		MaxAge:           86400, // 24 hours
	}
}

// CORS provides Cross-Origin Resource Sharing support
func CORS(config CORSConfig) fiber.Handler {
	return cors.New(cors.Config{
		AllowOrigins:     strings.Join(config.AllowOrigins, ","),
		AllowMethods:     strings.Join(config.AllowMethods, ","),
		AllowHeaders:     strings.Join(config.AllowHeaders, ","),
		AllowCredentials: config.AllowCredentials,
		MaxAge:           config.MaxAge,
	})
}

// ConcurrencyLimiter manages read/write concurrency
type ConcurrencyLimiter struct {
	readSemaphore  chan struct{}
	writeSemaphore chan struct{}
	timeout        time.Duration
}

// NewConcurrencyLimiter creates a new concurrency limiter
func NewConcurrencyLimiter(readLimit, writeLimit int, timeout time.Duration) *ConcurrencyLimiter {
	return &ConcurrencyLimiter{
		readSemaphore:  make(chan struct{}, readLimit),
		writeSemaphore: make(chan struct{}, writeLimit),
		timeout:        timeout,
	}
}

// WriteConcurrencyLimitMiddleware limits concurrent write operations
func WriteConcurrencyLimitMiddleware(limiter *ConcurrencyLimiter) fiber.Handler {
	return func(c *fiber.Ctx) error {
		select {
		case limiter.writeSemaphore <- struct{}{}:
			defer func() { <-limiter.writeSemaphore }()
			return c.Next()
		case <-time.After(limiter.timeout):
			return c.Status(503).JSON(fiber.Map{"error": "Service temporarily unavailable"})
		}
	}
}

// DefaultDevelopmentLoggerConfig returns logger config for development
func DefaultDevelopmentLoggerConfig() LoggerConfig {
	return LoggerConfig{
		Format:           "${time} ${status} - ${method} ${path} - ${latency}\n",
		SkipHealthChecks: false,
		SkipStaticAssets: false,
		SkipPaths:        []string{},
	}
}

// DefaultProductionLoggerConfig returns logger config for production
func DefaultProductionLoggerConfig() LoggerConfig {
	return LoggerConfig{
		Format:           `{"time":"${time}","status":${status},"method":"${method}","path":"${path}","latency":"${latency}","ip":"${ip}","user_agent":"${ua}"}` + "\n",
		SkipHealthChecks: true,
		SkipStaticAssets: true,
		SkipPaths:        []string{"/metrics", "/favicon.ico"},
	}
}

// DefaultRecoveryConfig returns default recovery configuration
func DefaultRecoveryConfig(enableStackTrace bool) RecoveryConfig {
	return RecoveryConfig{
		EnableStackTrace: enableStackTrace,
		SkipHealthChecks: false,
	}
}

// DefaultHelmetConfig returns default helmet configuration
func DefaultHelmetConfig(production bool) HelmetConfig {
	if production {
		return HelmetConfig{
			ReferrerPolicy: "strict-origin-when-cross-origin",
		}
	}
	return HelmetConfig{
		ReferrerPolicy: "no-referrer-when-downgrade",
	}
}

// AppTypeMiddlewareConfig holds middleware configurations for different app types
type AppTypeMiddlewareConfig struct {
	EnableCSRF      bool
	EnableCORS      bool
	EnableRateLimit bool
	CSRFConfig      CSRFConfig
	CORSConfig      CORSConfig
	RateLimitConfig RateLimiterConfig
	LoggerConfig    LoggerConfig
	RecoveryConfig  RecoveryConfig
	HelmetConfig    HelmetConfig
}

// NewAppTypeMiddlewareConfig creates middleware config based on app type and environment
// csrfExcludedPaths: Global CSRF excluded paths that override default paths
func NewAppTypeMiddlewareConfig(appType int, environment string, csrfExcludedPaths []string) AppTypeMiddlewareConfig {
	isProduction := environment == EnvProduction

	// Base configuration
	config := AppTypeMiddlewareConfig{
		LoggerConfig:   DefaultDevelopmentLoggerConfig(),
		RecoveryConfig: DefaultRecoveryConfig(!isProduction),
		HelmetConfig:   DefaultHelmetConfig(isProduction),
	}

	if isProduction {
		config.LoggerConfig = DefaultProductionLoggerConfig()
	} // App type specific configurations
	switch appType {
	case 0: // AppTypeGeneric
		config.EnableCSRF = true
		config.EnableCORS = false
		config.EnableRateLimit = false
		config.CSRFConfig = DefaultCSRFConfig()
		// Override with global excluded paths if provided
		if len(csrfExcludedPaths) > 0 {
			config.CSRFConfig.ExcludedPaths = csrfExcludedPaths
		}
		if isProduction {
			config.CSRFConfig.CookieSecure = true
		}

	case 1: // AppTypeFullStack
		config.EnableCSRF = true
		config.EnableCORS = false
		config.EnableRateLimit = false
		config.CSRFConfig = DefaultCSRFConfig()
		// Override with global excluded paths if provided
		if len(csrfExcludedPaths) > 0 {
			config.CSRFConfig.ExcludedPaths = csrfExcludedPaths
		}
		if isProduction {
			config.CSRFConfig.CookieSecure = true
		}

	case 2: // AppTypeAPIOnly
		config.EnableCSRF = false
		config.EnableCORS = true
		config.EnableRateLimit = true
		config.CORSConfig = DefaultCORSConfig()
		config.RateLimitConfig = DefaultRateLimiterConfig()
		if isProduction {
			config.CORSConfig = ProductionCORSConfig([]string{})
			config.RateLimitConfig.Max = 60
			config.RateLimitConfig.Duration = 1 * time.Minute
		}
	}

	return config
} // IsExcludedPath checks if a path should be excluded from middleware
func IsExcludedPath(path string, excludedPaths []string) bool {
	for _, excluded := range excludedPaths {
		if strings.HasPrefix(path, excluded) {
			return true
		}
	}
	return false
}

// SecurityHeaders represents common security headers
type SecurityHeaders struct {
	ContentTypeOptions    string
	FrameOptions          string
	XSSProtection         string
	ReferrerPolicy        string
	ContentSecurityPolicy string
}

// DefaultSecurityHeaders returns default security headers
func DefaultSecurityHeaders() SecurityHeaders {
	return SecurityHeaders{
		ContentTypeOptions:    "nosniff",
		FrameOptions:          "DENY",
		XSSProtection:         "1; mode=block",
		ReferrerPolicy:        "strict-origin-when-cross-origin",
		ContentSecurityPolicy: "default-src 'self'",
	}
}

// AuthenticationMiddleware creates a Fiber-compatible authentication middleware
// that works with Cartridge's interface-based authentication system
func AuthenticationMiddleware(config AuthMiddlewareConfig) fiber.Handler {
	requireAuth := RequireAuthInterface(config)
	
	return func(c *fiber.Ctx) error {
		// Create Cartridge context for this request
		// This would typically be done by the app's HandlerFunc wrapper
		// but for middleware, we need to create it manually
		
		// Note: This assumes the app context is available in Fiber locals
		// In practice, this would be injected by the application setup
		appCtx, ok := c.Locals("cartridge_context").(*Context)
		if !ok {
			// Fallback: create minimal context (not ideal but functional)
			return c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{
				"error": "Cartridge context not available",
			})
		}
		
		// Set Fiber context in the Cartridge context
		appCtx.Fiber = c
		
		// Call the generic RequireAuth middleware
		if err := requireAuth(appCtx); err != nil {
			return err
		}
		
		return c.Next()
	}
}

// SimpleAuthenticationMiddleware creates a simpler authentication middleware
// that uses basic redirect-based authentication without complex context management
func SimpleAuthenticationMiddleware(
	userFinder func(userID string) (User, error),
	authConfig CookieAuthConfig,
	loginRedirectPath string,
) fiber.Handler {
	if loginRedirectPath == "" {
		loginRedirectPath = "/admin/login"
	}
	
	return func(c *fiber.Ctx) error {
		// Get session data using cartridge's auth system
		sessionData, err := GetAuthCookie(c, authConfig)
		if err != nil || sessionData == nil {
			return c.Redirect(loginRedirectPath)
		}

		// Find user in database
		user, err := userFinder(sessionData.UserID)
		if err != nil {
			return c.Redirect(loginRedirectPath)
		}

		// Store current user in Fiber locals for handlers to use
		c.Locals("current_user", user)
		return c.Next()
	}
}
